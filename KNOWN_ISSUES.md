# **Известные недостатки и сомнения по решению**

1. **Производительность поиска целей в RangedAttack**:

   - Текущая реализация использует `getUnitsInRadius` для предварительного фильтра целей в квадрате вокруг актора (Chebyshev distance), что более эффективно, чем перебор всех клеток карты.
   - Однако для очень больших карт и большого количества юнитов это все еще может быть неэффективно, так как перебираются все живые юниты.
   - Возможное улучшение: использовать пространственные структуры данных (quadtree, grid) или кешировать список живых юнитов, отсортированный по позициям.
2. **Использование разных метрик расстояния**:

   - **Chebyshev distance (L∞)**: используется для `getUnitsInRadius` (предварительный фильтр), движения (выбор ближайшей позиции), поиска 8 соседних клеток.
   - **Manhattan distance (L1)**: используется для дальней атаки (финальная проверка диапазона).
   - Это правильное решение, так как разные механики требуют разных метрик, но может быть неочевидно для новых разработчиков.
3. **Порядок действий при одинаковом приоритете**:

   - Если несколько действий имеют одинаковый приоритет и все доступны, выполняется первое в списке. Это детерминированно, но может быть не оптимально в некоторых случаях.
   - Текущая реализация соответствует требованиям задания.
4. **Обработка летающих юнитов**:

   - Логика для летающих юнитов (Ворон) заложена в `Unit` (флаги `isFlying`, `occupiesCell`).
   - Поддержка летающих юнитов реализована через `getUnitsInRadius`, который находит всех юнитов в радиусе, независимо от того, занимают ли они клетки.
   - Для полной реализации Ворона нужно будет:
     - Добавить проверку в `MeleeAttack`, чтобы летающие юниты не могли быть атакованы ближним боем.
     - Модифицировать `isInRangedAttackRange` в классе Ворона для снижения дальности атаки на 1.
   - Это не требуется по заданию, но архитектура позволяет легко добавить такую функциональность.
5. **Случайность**:

   - Используется `std::mt19937` с инициализацией через `std::random_device`. Это обеспечивает хорошую случайность, но результат не детерминирован между запусками (что и требуется по заданию).
6. **Проверка условий окончания**:

   - В `shouldContinue()` проверяется наличие доступных действий для каждого юнита. Это может быть немного избыточно, так как проверка выполняется каждый тик.
   - Возможное улучшение: кешировать результат или проверять только при изменении состояния юнитов.
7. **Удаление мертвых юнитов**:

   - Используется `std::remove_if` с `erase`, что эффективно, но может быть оптимизировано для больших количеств юнитов.
   - Текущая реализация корректна и эффективна для типичных случаев использования.
8. **Отсутствие валидации входных данных**:

   - Не проверяется, что характеристики юнитов (HP, Strength, Agility, Range) имеют разумные значения (не отрицательные, не слишком большие).
   - Для production кода стоило бы добавить такую валидацию.
   - Текущая реализация полагается на корректность входных данных из файла команд.
9. **Паттерн Flyweight для метаданных типа юнита**:

   - Изначально рассматривался паттерн Flyweight для хранения общих метаданных типа юнита (флаги `canMove`, `hasHp`, `isFlying`, `occupiesCell`).
   - Однако было решено не использовать его, так как `std::shared_ptr` (16 байт на 64-битных системах) + overhead на объект и control block весит значительно больше, чем простое хранение 4 булевых флагов (4 байта) напрямую в каждом юните.
   - Также из-за неполного раскрытия условия было тяжело выделить данные: какие относятся к конкретному юниту, а какие к типу
10. **Оптимизация `getUnitsInRadius`**:

    - Текущая реализация перебирает всех живых юнитов и проверяет расстояние до центра. Для большого количества юнитов это может быть неэффективно.
    - Возможное улучшение: использовать пространственные индексы или кешировать результаты для часто используемых радиусов.
11. **Кеширование `ActionContext`**:

    - Реализовано кеширование `ActionContext` с обновлением только `currentTick` для оптимизации.
    - Это хорошее решение, но может быть улучшено путем более тонкого управления жизненным циклом контекста.
12. **Проверка границ карты в `getCellsAtDistance`**:

    - Метод `getCellsAtDistance` проверяет, что координаты не станут отрицательными, но не проверяет верхние границы карты.
    - Это не проблема, так как валидация позиций выполняется в `Map::isValid` при использовании позиций.
    - Однако для полной корректности стоило бы добавить проверку границ карты в `getCellsAtDistance`, если известны размеры карты.
